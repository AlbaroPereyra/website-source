<html>
<head>
  <title>Introduction</title>
  <meta name="layout" content="_layout/docs.html"/>
  <meta name="bread1" content="Configuration" href="/docs/configuration/"/>
  <meta name="bread2" content="Reference" href="/docs/"/>
  <template id="menuNav"><#include "/_layout/_docs_nav_configuration.ftl"></template>
  <#assign reference="active">
</head>
<body>

<h2>Reference</h2>


<h3>ServerConfig options</h3>

<table class="table">
  <tr>
    <th>Property</th>
    <th nowrap="true">Default value</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>name</td>
    <td>db</td>
    <td>
      The name of the EbeanServer instance. Defaults to "db" and only needs to be set
      when we are using multiple named servers (typically with multiple databases).
    </td>
  </tr>

  <tr>
    <td>defaultServer</td>
    <td>true</td>
    <td>
      Set this to false when creating multiple named EbeanServer instances (as only
      one instance can be considered the "default").
    </td>
  </tr>

  <tr>
    <td>register</td>
    <td>true</td>
    <td>
      Set this to false we create an EbeanServer instance and we don't want to register
      it with the Ebean singleton.
    </td>
  </tr>

  <tr>
    <td>register</td>
    <td>true</td>
    <td>
      Set this to false we create an EbeanServer instance and we don't want to register
      it with the Ebean singleton.
    </td>
  </tr>


  <tr>
    <td>classes</td>
    <td>&lt;empty&gt;</td>
    <td>
      Entity classes and other interesting classes (listeners, controllers, custom scalar types etc).
      It is recommended that we add classes explicitly via <code>serverConfig.addClass()</code> such
      that we get good fast startup and do not use classpath scanning to find the entity classes etc.
    </td>
  </tr>

  <tr>
    <td>packages</td>
    <td>&lt;empty&gt;</td>
    <td>
      The packages to search/scan for entity classes etc. It is not recommended to use that and instead
      explicitly add each class. See classes.
    </td>
  </tr>

  <tr>
    <td>databasePlatform</td>
    <td>-</td>
    <td>
      The database platform to use. By default it is determined automatically from the JDBC DataSource.
    </td>
  </tr>

  <tr>
    <td>databasePlatformName</td>
    <td>-</td>
    <td>
      The database platform name. Used to explicitly specify a DatabasePlatform to use.
      With SQL Server we should specify the platform specifically as <code>sqlserver17</code> or
      <code>sqlserver16</code> - refer to <a href="/docs/testing/sqlserver"></a>.
      Otherwise we generally do not set this and let the platform be determined automatically
      from the JDBC DataSource.
    </td>
  </tr>

  <tr>
    <th colspan="3"><div class="mtm">Current user</div></th>
  </tr>

  <tr>
    <td>currentUserProvider</td>
    <td> </td>
    <td>
      Provides the current user for use with `@WhoCreated`, `@WhoModified`.
    </td>
  </tr>

  <tr>
    <th colspan="3"><div class="mtm">JDBC Batch</div></th>
  </tr>

  <tr>
    <td>persistBatch</td>
    <td>NONE</td>
    <td>
      Setting this to <code>ALL</code> means that JDBC batch would be on by default. The default of NONE
      means that JDBC batch isn't used by default when saving top level beans (but typically
      JDBC batch is used when saving beans via cascading).
    </td>
  </tr>

  <tr>
    <td>persistBatchOnCascade</td>
    <td>INHERIT</td>
    <td>
      Use for cascade persist JDBC batch mode. INHERIT means use the platform default which generally means
      it will use batch mode.
    </td>
  </tr>

  <tr>
    <td>persistBatchSize</td>
    <td>20</td>
    <td>
      The default batch size to use when not explicitly set on the transaction.
    </td>
  </tr>

  <tr>
    <th colspan="3"><div class="mtm">DataSource</div></th>
  </tr>

  <tr>
    <td>dataSource</td>
    <td>-</td>
    <td>
      The dataSource to use. When not set we expect dataSourceConfig to be used.
    </td>
  </tr>

  <tr>
    <td>dataSourceConfig</td>
    <td>-</td>
    <td>
      Configuration to use to create a DataSource when one isn't provided.
    </td>
  </tr>

  <tr>
    <td>autoReadOnlyDataSource</td>
    <td>false</td>
    <td>
      Set this to true to automatically have a read-only auto-commit based DataSource created
      using the dataSourceConfig options. This is generally a good idea providing a performance
      benefit for queries that are executed without an explicit transaction.
    </td>
  </tr>

  <tr>
    <td>readOnlyDataSourceConfig</td>
    <td>-</td>
    <td>
      Configuration to use when creating a read-only DataSource when one isn't provided.
    </td>
  </tr>

  <tr>
    <td>readOnlyDataSource</td>
    <td>-</td>
    <td>
      The explicitly set read only dataSource to use.
    </td>
  </tr>

  <tr>
    <th colspan="3"><div class="mtm">DDL and Migrations</div></th>
  </tr>

  <tr>
    <td>dbSchema</td>
    <td>-</td>
    <td>
      A DB schema to use. Typically used with Postgres for both running DB migrations and testing DDL.
    </td>
  </tr>


  <tr>
    <th colspan="3"><div class="mtm">Document Store</div></th>
  </tr>

  <tr>
    <td>docStoreOnly</td>
    <td>false</td>
    <td>
      Set this to true when only using a Document store rather than using both Document store and DBMS.
    </td>
  </tr>

  <tr>
    <td>docStoreConfig</td>
    <td>&nbsp;</td>
    <td>
      Document store configuration.
    </td>
  </tr>

  <tr>
    <th colspan="3"><div class="mtm">Multi-tenant</div></th>
  </tr>

  <tr>
    <td>tenantMode</td>
    <td>NONE</td>
    <td>
      One of NONE | DB | SCHEMA | CATALOG | PARTITION.
    </td>
  </tr>

  <tr>
    <td>currentTenantProvider</td>
    <td> </td>
    <td>
      Provides the current tenant.
    </td>
  </tr>

  <tr>
    <td>tenantDataSourceProvider</td>
    <td> </td>
    <td>
      Provides the DataSource for modes ...
    </td>
  </tr>

  <tr>
    <td>tenantSchemaProvider</td>
    <td> </td>
    <td>
      Provides the schema when mode=SCHEMA is used.
    </td>
  </tr>

  <tr>
    <td>tenantCatalogProvider</td>
    <td> </td>
    <td>
      Provides the catalog when mode=CATALOG is used.
    </td>
  </tr>


  <tr>
    <th colspan="3"><div class="mtm">General</div></th>
  </tr>

  <tr>
    <td>jsonDateTime</td>
    <td>MILLIS</td>
    <td>
      The JSON format used for DateTime types. Default to millis.
    </td>
  </tr>

  <tr>
    <td>jsonInclude</td>
    <td>ALL</td>
    <td>
      For writing JSON specify if null values or empty collections should be excluded.
      By default all values are included.
    </td>
  </tr>

  <tr>
    <td>jsonFactory</td>
    <td>-</td>
    <td>
      The Jackson JsonFactory to use.
    </td>
  </tr>

  <tr>
    <td>objectMapper</td>
    <td>-</td>
    <td>
      The Jackson ObjectMapper to use if/when marshalling beans to and from JSON. An ObjectMapper
      will be created if needed and it is available on the classpath.
    </td>
  </tr>

  <tr>
    <td>platformConfig</td>
    <td>PlatformConfig</td>
    <td>
      Database platform configuration for quoted identifiers, true value, UUID treatment.
    </td>
  </tr>

  <tr>
    <td>lazyLoadBatchSize</td>
    <td>10</td>
    <td>
      The default batch size for lazy loading
    </td>
  </tr>

  <tr>
    <td>queryBatchSize</td>
    <td>100</td>
    <td>
      The default batch size for 'query joins'.
    </td>
  </tr>

  <tr>
    <td>eagerFetchLobs</td>
    <td>false</td>
    <td>
      Set this to true if you want to globally eagerly fetch LOB properties.
    </td>
  </tr>

  <tr>
    <td>dataTimeZone</td>
    <td>-</td>
    <td>
      The timezone to use for DateTime based properties.
    </td>
  </tr>

  <tr>
    <td>jdbcFetchSizeFindList</td>
    <td>0</td>
    <td>
      JDBC fetchSize hint when using findList.  Defaults to 0 leaving it up to the JDBC driver.
    </td>
  </tr>

  <tr>
    <td>jdbcFetchSizeFindEach</td>
    <td>100</td>
    <td>
      JDBC fetchSize hint when using findEach/findEachWhile.  Defaults to 100. Note that this does
      not apply to MySql as that gets special treatment (forward only etc).
    </td>
  </tr>

  <tr>
    <td>namingConvention</td>
    <td>UnderscoreNamingConvention</td>
    <td>
      The naming convention to use to translate property names to column names etc.
    </td>
  </tr>

  <tr>
    <td>constraintNaming</td>
    <td>DbConstraintNaming</td>
    <td>
      Naming convention used in DDL generation for primary keys, foreign keys etc.
    </td>
  </tr>

  <tr>
    <td>updateChangesOnly</td>
    <td>true</td>
    <td>
      Behaviour of update to include on the change properties.
    </td>
  </tr>

  <tr>
    <td>updateAllPropertiesInBatch</td>
    <td>true</td>
    <td>
      Behaviour of updates in JDBC batch to by default include all properties.
    </td>
  </tr>

  <tr>
    <td>updatesDeleteMissingChildren</td>
    <td>true</td>
    <td>
      Default behaviour for updates when cascade save on a O2M or M2M to delete any missing children.
    </td>
  </tr>

  <tr>
    <td>uuidVersion</td>
    <td>VERSION4</td>
    <td>
      The UUID version to use.
    </td>
  </tr>

  <tr>
    <td>clock</td>
    <td>systemUTC</td>
    <td>
      The clock used for setting the timestamps (e.g. @UpdatedTimestamp) on objects.
    </td>
  </tr>

  <tr>
    <td>disableL2Cache</td>
    <td>false</td>
    <td>
      Set to true to globally disable L2 caching (typically for performance testing).
    </td>
  </tr>

  <tr>
    <td>notifyL2CacheInForeground</td>
    <td>false</td>
    <td>
      Generally we want to perform L2 cache notification in the background and not impact the performance
      of executing transactions. Set this to true to perform L2 cache notification in the foreground.
    </td>
  </tr>


  <tr>
    <td>expressionEqualsWithNullAsNoop</td>
    <td>false</td>
    <td>
      Set to true if you want eq("someProperty", null) to generate 1=1 rather than "is null" sql expression.
    </td>
  </tr>

  <tr>
    <td>expressionNativeIlike</td>
    <td>false</td>
    <td>
      Set to true to use native ILIKE expression (if support by database platform / like Postgres).
    </td>
  </tr>

  <tr>
    <td>useJavaxValidationNotNull</td>
    <td>true</td>
    <td>
      Should the javax.validation.constraints.NotNull enforce a notNull column in DB. If set to false,
      use io.ebean.annotation.NotNull or Column(nullable=true).
    </td>
  </tr>

  <tr>
    <td>slowQueryMillis</td>
    <td>&nbsp;</td>
    <td>
      The time in millis used to determine when a query is alerted for being slow.
    </td>
  </tr>

  <tr>
    <td>slowQueryListener</td>
    <td>&nbsp;</td>
    <td>
      The listener for processing slow query events. Defaults to logging.
    </td>
  </tr>

  <tr>
    <td>persistenceContextScope</td>
    <td>TRANSACTION</td>
    <td>
      The default PersistenceContextScope used if one is not explicitly set on a query. Set this to <code>QUERY</code>
      if we want the persistence context to be scoped per query by default.
    </td>
  </tr>

  <tr>
    <td>defaultOrderById</td>
    <td>false</td>
    <td>
      Controls the default order by id setting of queries. See Query.orderById(boolean)
    </td>
  </tr>

  <tr>
    <td>idGeneratorAutomatic</td>
    <td>&nbsp;</td>
    <td>
      When true we do not need explicit GeneratedValue mapping.
    </td>
  </tr>

  <tr>
    <td>mappingLocations</td>
    <td>&nbsp;</td>
    <td>
      The mappingLocations for searching xml mapping.
    </td>
  </tr>

  <tr>
    <td colspan="3">&nbsp;</td>
  </tr>


</table>


<div class="next pull-right">
  <a href="/docs/configuration/spring" class="btn btn-info">Next: Spring</a>
</div>
</body>
</html>
