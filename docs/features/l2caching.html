<html>
<head>
  <meta name="layout" content="_layout/docs_features.html"/>
<#assign subtitle = "L2 caching">
<#assign l2caching = "true">
</head>
<body>
<div class="bs-docs-section">
  <h1 id="overview">Overview</h1>
  <p>
    When we want to talk about caching for performance we are talking about the "Level 2"
    cache or the "server cache". It is called the "Level 2 cache" because the persistence
    context is often referred to as the "Level 1 cache".
  </p>
  <p>
    The goal of the L2 server cache is to gain very significant performance improvement by
    not having to hit the database. Ebean has 2 types of caches – Bean caches and Query caches.
  </p>

  <h4>Bean Caches</h4>
  <p>
    Bean caches hold entity beans and are keyed by their Id values. The bean cache can be used with:
  </p>
  <ul>
    <li>Find by id query</li>
    <li>Find unique by "natural key" query</li>
  </ul>

  <h4>Query Caches</h4>
  <p>
    Query caches hold the results of queries (Lists, Sets, Maps of entity beans) and are keyed
    by the query hash value (effectively a hash of the query and its bind values).
    The entries in a query cache are invalidated by ANY change to the underlying table –
    insert, update or delete. This means that the query cache is only useful on entities that are
    infrequently modified (typically "lookup tables" such as countries, currencies, status codes
    etc).
  </p>
  <p>
    The query cache can be used with:
  </p>
  <ul>
    <li>Find list/set/map queries</li>
  </ul>

  <h2 id="l2-l3">L2/local and L3/remote</h2>
  <p>
    L2 cache can thought of as having <code>Near Caches</code> and <code>Remote Caches</code> where
    a "Near cache" is in the same process as the EbeanServer instance (and does not require a network
    access) and a "Remote cache" that requires a network access.
  </p>

  <h4>L3 bean cache options</h4>
  <p>
    The following are the 3 main approaches when we get a miss on the a local L2 bean cache.
  </p>
  <ul>
    <li>Use nothing and hit the database</li>
    <li>Use <a href="https://hazelcast.com/">Hazelcast</a>, <a href="http://infinispan.org/">Infinispan</a> or similar data grid/key value store</li>
    <li>Use <a href="">ElasticSearch</a></li>
  </ul>
  <p>
    The L2 bean cache is keyed by id value so really anything resembling a key value store (distributed map)
    works well for bean caching.
  </p>
  <p>
    Note that ElasticSearch has the advantage that we update it with changes (as deltas to documents) rather than
    remove/invalidate an entry in a map so with ElasticSearch we are always going to get a hit (and hence always
    avoid hitting the database). There is also the potential benefit that ElasticSearch documents will often contain
    denormalisation (embedded documents) so a hit against ElasticSearch will populate more of the graph and avoid
    extra hits.  For example, a hit of an order can populate customer details like customer name.
  </p>

  <h4>L3 query cache options</h4>
  <p>
    The following are the 2 main approaches when we get a miss on the local L2 query cache.
  </p>
  <ul>
    <li>Use nothing and hit the database</li>
    <li>Use <a href="">ElasticSearch</a></li>
  </ul>
  <p>
    The significant benefit of using <code>ElasticSearch</code> is that it can address both parts of the L2 cache
    meaning that we can use it for <code>L2 query cache</code> (by translating ORM queries into ElasticSearch queries)
    as well as the <code>L2 bean cache</code>.
  </p>
  <p>
    We can update ElasticSearch as changes occur and use the performance of inverted indexes to perform very fast
    queries (avoiding the database hit like L2 query cache but not having the issue of frequent invalidation that
    L2 query cache suffers from).
  </p>

  <h4>ElasticSearch</h4>
  <p>
    The current emphasis for Ebean ORM is to utilise ElasticSearch as the best L3 cache option.
    This means that
  </p>

  <h2 id="read-consistency">Read consistency</h2>
  <blockquote>
    With Ebean L2 caching there is no attempt to provide transactional read consistency
  </blockquote>
  <p>
    ACID/Transactional databases do a lot of things for us and this includes providing "read consistency"
    based on transaction isolation levels (MVCC databases like Postgres and Oracle emphasis this more).
  </p>
  <p>
    With Ebean L2 caching there is <code>no attempt to provide transactional read consistency</code>.
    What that means is that if part of your application needs transactional read consistency then
    <code>use the database</code> to do that.
  </p>
  <blockquote>
    L2 cache works to eventual consistency
  </blockquote>
  <p>
    Instead with Ebean L2 caching the view is that eventual consistency is good enough, much simpler
    and a more natural approach when using ElasticSearch.  Given what ElasticSearch is doing for us
    behind the scenes (flush, merge, optimise etc) in order to provide inverted index awesomeness
    we happily go with eventual consistency and the associated simplicity.
  </p>

  <h5>Near cache</h5>
  <p>
    With Ebean the view is that the cost of trying to make L2 caching read consistent is not worth it.
    Instead we treat the L2 cache as <code>reasonably up to date</code>. In practical terms this means that
    cache invalidation occurs in the background after successful commits. L2 near caches are invalidated across
    the cluster very quickly (millisecond) but this is not strictly transactional (there is a delay after the commit).
  </p>

  <h5>ElasticSearch</h5>
  <p>
    When we use ElasticSearch the delay of a change (insert, update, delete) being visible in ElasticSearch
    is going to be longer with a default of <code>1 second delay</code> but for various bean types
    and use cases we may choose to increase that delay to support more throughput or be more efficient overall.
    This is similar to decisions on how frequently <code>database materialised views</code> should be updated.
  </p>

  <h2 id="table-iud-invalidation">Table IUD invalidation (Bulk updates)</h2>
  <p>
    Bulk insert, update or delete events are processed by table. For a given table the bean types
    that depend on that table are determined and then for each bean type the L2 bean cache and L2 query cache
    are invalidated as necessary.
  </p>
  <h4>Cluster message</h4>
  <p>
    The message sent around the cluster contains the table name and boolean flags for insert, update and delete.
  </p>
  <h4>L2 query cache</h4>
  <ul>
    <li><code>Inserts, updates or deletes:</code> Invalidate the entire L2 query cache for the related bean type</li>
  </ul>
  <p>
    For any bulk statements (bulk table insert, update or delete statement) the entire L2 query cache is invalidated
    for the associated bean type.
    For example, a bulk update of the customer table invalidates the entire L2 query cache for the Customer bean type.
  </p>
  <h4>L2 bean cache</h4>
  <ul>
    <li><code>Inserts:</code> Do not effect the L2 bean cache</li>
    <li><code>Updates:</code> Invalidate the entire L2 bean cache for the related bean type</li>
    <li><code>Deletes:</code> Invalidate the entire L2 bean cache for the related bean type</li>
  </ul>

  <h2 id="bean-iud-invalidation">Bean IUD invalidation</h2>
  <p>
    Persisted beans are processed by bean type and id value.
  </p>
  <h4>Cluster message</h4>
  <p>
    The message sent around the cluster contains the bean type and 3 lists of ids - a list of id values for inserted, updated and deleted beans.
  </p>

  <h4>L2 query cache</h4>
  <ul>
    <li><code>Inserts, updates or deletes:</code> Invalidate the entire L2 query cache for the bean type</li>
  </ul>
  <p>
    For any bean persist event invalidates the entire related L2 query cache for the associated bean type.
    For example, saving a customer bean invalidates the entire L2 query cache for the Customer bean type.
  </p>

  <h4>L2 bean cache</h4>
  <ul>
    <li><code>Inserts:</code> Do not effect the L2 bean cache</li>
    <li><code>Updates:</code> An entry is removed from the L2 bean cache based on the id value</li>
    <li><code>Deletes:</code> An entry is removed from the L2 bean cache based on the id value</li>
  </ul>

  <h2 id="read-only-instances">Read only instances</h2>
  <p>
    For a performance optimisation when using the cache you can inform Ebean that you
    want "read only" entities. If you ask for "read only" entities Ebean can give you the
    instance that is in the cache rather than creating a new copy (creating a new instance and
    copying the data from the cached instance).
  </p>
  <p>
    To be safe in allowing many threads to share the same instances (from the cache) Ebean
    ensures that these instances can not be mutated. It sets flags (sharedInstance=true,
    readOnly=true) and any attempt to modify the entity (via setters or putfields) results in an
    IllegalStateException being thrown.
  </p>

  ```java
  // Cache countries. Use readOnly=true so unless explicitly
  // stated in the query we will return read only/shared instances
  @CacheStrategy(readOnly=true)
  @Entity
  @Table(name="o_country")
  public class Country {
  ```

  <p>
    Note that Countries is a good candidate for a default setting of readOnly=true. This is
    because (for my application) country information is very rarely changed. The application
    code mostly treats the countries as read only.
  </p>

  <p>
    Now, whenever we get a country (via direct query or indirectly via relationships/joins) unless
    we explictly say query.setReadOnly(false) we are going to get back readOnly instances that
    we will not be able to mutate.
  </p>

  ```java
  // we will use the cache .. and the instance
  // in the cache is returned to us (not a copy)
  Country country = Ebean.find(Country.class, "NZ");

  // this country instance is readOnly
  Assert.assertTrue(Ebean.getBeanState(country).isReadOnly());
  try {
    // we can't modify a readOnly bean
    // … a IllegalStateException is thrown
    country.setName("Nu Zilund");
    Assert.assertFalse("Never get here",true);
  } catch (IllegalStateException e){
    Assert.assertTrue("This is readOnly",true);
  }

  // explicitly state we want a MUTABLE COPY
  // … not the same instance as the one in cache
  // … a copy is made and returned instead
  Country countryCopy = Ebean.find(Country.class)
  .setReadOnly(false)
  .setId("NZ")
  .findUnique();

  // we can mutate this one
  countryCopy.setName("Nu Zilund");

  // save it, automatically maintaining the cache ...
  // evicting NZ from the Country bean cache and
  // clearing the Country query cache
  Ebean.save(countryCopy);
  ```

  <h2 id="shared-instances">Shared instances</h2>
  <p>
    Ebean sets a sharedInstance flag on a bean whenever it is put into the cache. This is
    used to ensure that the bean is always treated in a read only fashion (and can be safely
    shared by multiple threads concurrently).
  </p>

  <p>
    You can invoke lazy loading on a sharedInstance. When that occurs the sharedInstance
    flag is propagated to the lazily loaded beans. If you lazy load a collection (list, set or map)
    then the collection is also marked with the sharedInstance flag and that means you can't
    add or remove elements from the collection (list, set or map).
  </p>

  <p>
    A sharedInstance and all its associated beans and collections are are all ensured to be
    read only and can be safely shared by multiple threads concurrently.
  </p>

  <h2 id="external-mods">External modification</h2>

  <p>
    When you save/delete beans via Ebean.save() and Ebean.delete() etc Ebean will
    automatically maintain its cache (removing cached beans and cached queries as
    appropriate). However, you may often find yourself modifying the database outside of
    Ebean. (via stored procedures etc)
  </p>

  <p>
    For example, you could be using other frameworks, your own JDBC code, stored
    procedures, batch systems etc. When you do so (and you are using Ebean caching) then
    you can inform Ebean so that it invalidates appropriate parts of its cache.
  </p>

  ```java
  // inform Ebean that some rows have been inserted and updated
  // on the o_country table.
  // … Ebean will maintain the appropriate caches.
  boolean inserts = true;
  boolean updates = true;
  boolean deletes = false;
  Ebean.externalModification("o_country", inserts, updates, deletes);

  // clearAll() caches via the ServerCacheManager ...
  ServerCacheManager serverCacheManager =
  Ebean.getServerCacheManager();

  // Clear all the caches on the default/primary EbeanServer
  serverCacheManager.clearAll();

  // clear both the bean and query cache
  // for Country beans ...
  serverCacheManager.clear(Country.class);

  // Warm the cache of Country beans
  Ebean.runCacheWarming(Country.class);
  ```

  <h2 id="cachestrategy">@CacheStrategy</h2>

  <p>
    CacheStrategy provides a way to automatically use the bean cache.
  </p>

  <p>
    The easiest way to use caching is to specify the @CacheStrategy annotation on the entity
    class. This means that Ebean will try to use the bean cache as much as possible when it
    fetches beans of that type.
  </p>

  ```java
  // Cache countries. Use readOnly=true so unless explicitly
  // stated in the query we will return read only/shared instances
  @CacheStrategy(readOnly=true)
  @Entity
  @Table(name="o_country")
  public class Country {
  ```

  ```java
  // automatically use the cache
  Country country = Ebean.find(Country.class,"NZ");
  // references automatically use the cache too
  Country countryRef = Ebean.getReference(Country.class,"NZ");
  // hit the country cache automatically via join
  Customer customer = Ebean.find(Customer.class, 1);
  Address billingAddress = customer.getBillingAddress();
  Country c2 = billingAddress.getCountry();
  ```

  <h2>ReadOnly</h2>
  ```java
  @CacheStrategy(readOnly=true)
  ```
  <p>
    The readOnly attribute of @CacheStrategy is used to determine if by default Ebean
    should return the same instance from the cache (instances in the cache are readOnly and
    effectively immutable) or whether Ebean should create a new instance and copy the data
    from the cached bean onto the new instance.
  </p>

  <p>
    The readOnly attribute of @CacheStrategy is the "default" Ebean will use unless you
    explicitly specify the readOnly attribute of the query.
  </p>

  ```java
  // explicitly state we want a MUTABLE COPY
  // … not the same instance as the one in cache
  // … a copy is made and returned instead
  Country countryCopy = Ebean.find(Country.class)
    .setReadOnly(false)
    .setId("NZ")
    .findUnique();

  // we can mutate this one
  countryCopy.setName("Nu Zilund");

  // save it, automatically maintaining the cache ...
  // evicting NZ from the Country bean cache and
  // clearing the Country query cache
  Ebean.save(countryCopy);
  ```

  <h2 id="query-bean-cache">Query - use bean cache</h2>
  <p>
    If you don't use @CacheStrategy you can programmatically specify to use the bean cache via query.setUseCache(true);
  </p>

  ```java
  // explicitly state we want to use the bean cache
  Customer customer = Ebean.find(Customer.class)
    .setUseCache(true)
    .setId(7)
    .findUnique();

  // use readOnly=true to return the 'sharedInstance'
  // from the cache (which is effectively immutable)
  Customer customer = Ebean.find(Customer.class)
    .setUseCache(true)
    .setReadOnly(true)
    .setId(7)
    .findUnique();
  ```

  <h2 id="query-query-cache">Query - use query cache</h2>
  <p>
    To use the query cache you have to explicitly specify its use on a query.
  </p>

  ```java
  // use the query cache
  List<Country> list = Ebean.find(Country.class)
    .setUseQueryCache(true)
    .where().ilike("name", "New%")
    .findList();
  ```
  <p>
    The query cache is generally useful for returning lists that are very infrequently changed.
    These lists would often be used to populate drop down lists / combo boxes in user interfaces.
  </p>

  <p>
    If you are familiar with the term "Lookup Tables" or "Reference Tables" these are typical candidates
    for using cached queries. Some examples of lookup/reference tables could be, countries, currencies
    and order status.
  </p>
  <p>
    Query cache lists are readOnly by default.
  </p>

  ```java
  // by default the lists returned from the query
  // cache are readOnly. Use setReadOnly(false) to
  // return mutable lists
  List<Country> list = Ebean.find(Country.class)
    .setUseQueryCache(true)
    .setReadOnly(false)
    .where().ilike("name", "New%")
    .findList();
  ```
  </p>

</div>
</body>
</html>