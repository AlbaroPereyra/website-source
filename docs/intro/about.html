<html>
<head>
<meta name="layout" content="_layout/intro.html" />
<#assign about="active">
</head>
<body>

<h1>Introduction</h1>
<h4>Ebean ORM - simple, elegent, fun</h4>


<div class="container">

  <div class="row">


<div class="col-md-3">
  <div class="well">
  <h4>Simple to learn</h4>
  <p>
Ebean's goal is to be simple to use and understand. Developers should be able to be productive quickly and get stuff done without fuss or worry.
  </p>
  </div>
</div>

<div class="col-md-3">
  <div class="well">
  <h4>Elegant</h4>
  <p>
Large queries, batch processing, need to use raw SQL  - Ebean will elegantly handle your more difficult requirements.
  </p>
  </div>
</div>

<div class="col-md-3">
  <div class="well">
  <h4>Performance</h4>
  <p>
Ebean is designed for performance. Fetch only what you need using 'partial objects', query joins, batch lazy loading.
  </p>
  </div>
</div>

  </div> <!-- ./row -->
</div>


<h2>Use JPA Mapping</h2>
<p>
Use standard JPA Mapping annotations - @Entity, @Table, @Id etc.
</p>

```java

/**
 * Use standard JPA Mapping annotations.
 */
@Entity
@Table(name = "o_customer")
public class Customer {

  @Id
  Long id;

  @Version
  Long version;

  String name;

  @ManyToOne
  Address address;

  @OneToMany(mappedBy = "customer")
  List<Order> orders;

  // getters and setters
  
}



```

<h2>Simple query language</h2>
<p>
Ebean provides a simple query language. It will determine what joins are required to support your WHERE clause and add them as appropriate
so that the developer can concentrate on  by doing some of the work for you.
</p>


```java

@Inject
EbeanServer server;

...
public void processOrder() {

  // find order
  List<Order> orders = 
         server.find(Order.class)
         .where()
           .eq("customer.id", customerId)
           .gt("shipDate", lastWeek)
         .findList();
  
  // eq = equal to
  // gt = greater than

  // find customer by id  
  Customer customer = server.find(Customer.class, customerId); 


  List<Customer> customers = 
      server.find(Customer.class)
       // just fetch the properties you need
      .select("name, status")
      .where()
        .eq("status", Status.NEW)
        .ilike("name", "rob%")
      .orderBy("name")
      .findList(); 

}

```

<h2>Use the Transaction</h2>
<p>
You can use the Transaction to explicitly control behaviour.
</p>


```java


Transaction transaction = ebeanServer.beginTransaction();  
try {  
  // turn of cascade persist
  transaction.setCascadePersist(false);

  // control the jdbc batch mode and size
  transaction.setBatchMode(true);
  transaction.setBatchSize(30);
  
  // for a large batch insert if you want to skip 
  // getting the generated keys
  transaction.setBatchGetGeneratedKeys(false);

  // for batch processing via raw SQL you can inform
  // Ebean what tables were modified so that it can 
  // clear the appropriate L2 caches
  String tableName = "o_customer";
  boolean inserts = true;
  boolean upates = true;
  boolean deletes = false;
  transaction.addModification(tableName, inserts, updates, deletes);

  ...
} finally {
  transaction.end();
}  
      

```

</body>
</html>
