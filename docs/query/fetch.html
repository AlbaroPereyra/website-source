<html>
<head>
  <meta name="layout" content="_layout/docs_query_select.html"/>
  <meta name="bread2" content="Fetch" href="/docs/query/fetch"/>
  <#assign fetch= "true">
</head>
<body>
<h2>Fetch</h2>
<p>
  With fetch we specify the properties that should be fetched on associated beans. Beans that
  are related by <em>OneToOne, OneToMany, ManyToOne and ManyToMany</em>.
</p>

<p>&nbsp;</p>
<h4>Query bean example</h4>
<p>
  When using query beans we use <code>alias</code> beans to provide properties for both <em>select</em>
  and <em>fetch</em>.
</p>

```java
// "alias" beans for customer and contact which
// we use to specify the properties to select and fetch
QCustomer cust = QCustomer.alias();
QContact con = QContact.alias();

// using query beans
List<|Customer> customers =
  new QCustomer()
  .select(cust.name, cust.version, cust.whenCreated)   // type safe select
  // eagerly fetch contacts (only the email property)  // type safe fetch
  .contacts.fetch(con.email)

  .name.istartsWith("Rob")
  .findList();
```

<p>
  The resulting sql for the above query is:
</p>
```sql
select t0.id, t0.name, t0.version, t0.when_created, t1.id, t1.email
from customer t0
left join contact t1 on t1.customer_id = t0.id
where lower(t0.name) like ? escape'|' order by t0.id; --bind(rob%)
```
<p>
  The <em>contacts</em> path is a <em>@OneToMany</em> so we get a <em>left join</em> to the
  contact table. We only fetch the contact id and email properties.
</p>

<p>&nbsp;</p>
<h4>Kotlin "alias" beans</h4>
<p>
  For Kotlin the <em>alias</em> beans are a companion object of the query bean
  and accessed via <code>_alias</code>. Otherwise the queries are the same in Kotlin.
</p>
```kotlin
val cust = QCustomer._alias
val con = QContact._alias
```

<h4>Standard query example</h4>
<p>
  The above query written as a standard query is:
</p>

```java
// using standard query
List<|Customer> customers =
  ebeanServer.find(Customer.class)
  .select("name, version, whenCreated")
  .fetch("contacts", "email")

  .where()
  .istartsWith("name", "Rob")
  .findList();
```

<h2 id="fetch">fetch()</h2>
<p>
  When we specify to <code>fetch</code> a given path that is telling Ebean that we want to eagerly load
  that path and that we <em>PREFER</em> for that to happen as a <em>SQL JOIN</em>.
</p>
<p>
  Ebean enforces rules that limit the number of sql joins that it will allow when translating ORM query into
  SQL queries. Those rules are:
</p>
<ul>
  <li>Ebean will not generate a SQL cartesian product</li>
  <li>Ebean will honor maxRows in SQL</li>
</ul>

<h3>SQL Cartesian product</h3>
<p>
  This rule has the implication that Ebean will allow at most 1 join to a <code>OneToMany</code> path
  or a <code>ManyToMany</code> path. If the ORM query has more than 1 of those paths then the ORM query will
  be translated and executed as multiple SQL queries.
</p>
<p>
  We avoid sql cartesian product because it has a high risk of producing a very very bad sql query.
</p>

<h3>Honor maxRows in SQL</h3>
<p>
  This rule has the implication that Ebean can not include any joins to a <code>OneToMany</code> path
  or a <code>ManyToMany</code> path if there is a <code>maxRows</code>. This is because SQL max rows
  works on rows so we can't include SQL joins to paths that have a cardinality of more than 1.
</p>
<p>
  Honoring maxRows is SQL is important because the database can typically give us a way better query plan and
  more efficient sql queries.
</p>

<h2 id="fetchQuery" class="art">fetchQuery()</h2>
<p>
  When we specify <em>fetchQuery</em> we are telling Ebean that we want this path fetched eagerly but that
  we want that to be done using a separate sql query (known as a "secondary query" or "query join").
</p>
<p>
  We choose to do this on specific paths because we know the relative costs of joins vs query joins etc.
</p>

<h2 id="fetchLazy">fetchLazy()</h2>
<p>
  With <em>fetchLazy</em> we are telling Ebean that we don't want to eagerly
  fetch this path BUT if it is lazy loaded we are optimising what the lazy loading query will fetch.

</p>
<h5>e.g. when lazy loading Customer only fetch the name.</h5>
```java
List<|Order> orders =
  new QOrder()
    .fetchLazy("customer", "name")
    .findList();
```

<h5>e.g. when lazy loading Customer additionally fetch the billingAddress and shippingAddress.</h5>
```java
List<|Order> orders =
  new QOrder()
    .fetchLazy("customer")
    .fetch("customer.billingAddress")  // fetched with lazy load of customer
    .fetch("customer.shippingAddress") // fetched with lazy load of customer

    .findList();
```

<@next "FetchGroup" "/docs/query/fetchgroup"/>
<@edit "/docs/query/fetch"/>

</body>
</html>
