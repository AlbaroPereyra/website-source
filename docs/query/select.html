<html>
<head>
  <meta name="layout" content="_layout/docs_query_select.html"/>
  <meta name="bread2" content="Select" href="/docs/query/select"/>
  <#assign select= "true">
</head>
<body>

<h2>Select</h2>
<p>
  <code>select</code> allows us to control the properties that are fetched. We can specify only selected
  properties to fetch.
</p>
```java
List<Customer> customers =
  query()
    .select("name, registered, version")
    .findList();
```
<p>
  With the above we specify the properties we want to fetch. We still get Customer entity beans returned
  but they are <b>partially populated</b>.
</p>
<p>
  The SQL generated by the above query has:
</p>
```sql
  select t0.id, t0.name, t0.registered, t0.version from customer t0
```
<p>
  Note that the <code>@Id</code> property is automatically included for most queries and it is
  automatically exludeded for <b>distinct</b>, <b>findSingleAttribute</b> and <b>aggregation</b> queries.
</p>


<h4>Query beans</h4>
<p>
  Query beans provide a type safe way to define what part of the object graph to fetch in
  addition to the approaches provided via the normal Query.
</p>
<p>
  Each query bean provides an <em>alias</em> bean that can be used in <em>select</em> and <em>fetch</em>.
</p>
<p>
  In the example below we specify which properties to include in the select and only these
  properties are loaded into the entity beans. This is described as "partial object".
</p>
```java

// "alias" bean that can be used in select and fetch clauses
QCustomer cust = QCustomer.alias();

List<|Customer> customers =
  new QCustomer()
  // only fetch some properties of customer (partial objects)
  .select(cust.name, cust.version, cust.whenCreated)
  .name.istartsWith("Rob")
  .findList();

```
<p>
  The above query produces the following sql:
</p>
```sql
select t0.id, t0.name, t0.version, t0.when_created
from customer t0
where lower(t0.name) like ? escape'|'; --bind(rob%)
```


<h2 class="art">Standard query select and fetch</h2>
<p>
  The standard query select and fetch take strings so are not type safe per say.
</p>
<p>
  The following examples produce the same query as above but specify the <em>select</em>
  and <em>fetch</em> via strings in a non type safe way.
</p>
```java

List<|Customer> customers =
  new QCustomer()
  // only fetch some properties of customer (partial objects)
  .select("name, version, whenCreated")
  .name.istartsWith("Rob")
  .findList();

```
```java

List<|Customer> customers =
  new QCustomer()
  // fetch some properties of customer
  // and the associated contacts
  .select("name, version, whenCreated")
  .fetch("contacts", "email")

  .name.istartsWith("Rob")
  .findList();

```
<h4>Formula</h4>
<p>
  We need to use this string select clause when we want to specify a formula.
</p>
```java
// java
List<|String> names =
  new QContact()
    .select("concat(lastName,', ',firstName)")
    .lastName.startsWith("A")
    .findSingleAttributeList();
```
```java
// kotlin
var names: List<|String> =
  QContact()
    .select("concat(lastName,' ',firstName)")
    .lastName.startsWith("A")
    .findSingleAttributeList()
```



<h5>Example - Postgis ST_Distance formula</h5>
<p>
  With this example we explicitly cast to a Java BigDecimal type using
  the <code>::BigDecimal</code> cast at the end of the formula.
</p>
```java
// given route is a Postgis geometry(linestring,4326)
// return the distance between the start and end points

BigDecimal routeDistance = query()
  .select("ST_Distance(ST_StartPoint(route), ST_EndPoint(route))::BigDecimal")
  .where()
  .idEq(tripId)
  .findSingleAttribute();
```

<h4>Aggregation</h4>
<p>
  Similarly when we want to use an aggregation query we use this string select clause.
</p>
<h5>Single aggregation queries</h5>
```java
// java
Timestamp maxWhen  =
  new QContact()
    .select("max(whenModified)")
    .findSingleAttribute()
```

```java
// kotlin
var maxWhen: Timestamp =
  QContact()
    .select("max(whenModified)")
    .findSingleAttribute()
```
```sql
select max(t0.when_modified) from contact t0
```


<h5>Group by aggregation queries</h5>
<p>
  Similarly for a multiple column aggregation query we use the string select clause.
</p>
```java
List<|MachineStats> result =
  new QMachineStats()
  .select("machine, date, max(rate)")
  .date.gt(LocalDate.now().minusDays(10))
  .query().having().gt("max(rate)", 4)
  .findList();
```
<p>
  The above query produces the following sql:
</p>
```sql
select t0.machine_id, t0.date, max(t0.rate)
from d_machine_stats t0
where t0.date > ?
group by t0.machine_id, t0.date
having max(t0.rate) > ?
```


<@next "Fetch" "/docs/query/fetch"/>
<@edit "/docs/query/select"/>

</body>
</html>
